use multiversx_chain_vm_executor::VMHooksError;
use num_bigint::{BigInt, BigUint};

use crate::{
    host::vm_hooks::{VMHooksHandlerSource, VMHooksManagedTypes},
    types::RawHandle,
};

/// Interface to only be used by code generated by the macros.
/// The smart contract code doesn't have access to these methods directly.
pub trait VMHooksEndpointFinish: VMHooksHandlerSource + VMHooksManagedTypes {
    fn finish_slice_u8(&mut self, slice: &[u8]) -> Result<(), VMHooksError> {
        let mut v = vec![0u8; slice.len()];
        v.copy_from_slice(slice);
        let mut tx_result = self.result_lock();
        tx_result.result_values.push(v);

        Ok(())
    }

    fn finish_big_int_raw(&mut self, handle: RawHandle) -> Result<(), VMHooksError> {
        let bi_bytes = self.bi_get_signed_bytes(handle)?;
        let mut tx_result = self.result_lock();

        tx_result.result_values.push(bi_bytes);

        Ok(())
    }

    fn finish_big_uint_raw(&mut self, handle: RawHandle) -> Result<(), VMHooksError> {
        let bu_bytes = self.bi_get_unsigned_bytes(handle)?;
        let mut tx_result = self.result_lock();
        tx_result.result_values.push(bu_bytes);

        Ok(())
    }

    fn finish_managed_buffer_raw(&mut self, handle: RawHandle) -> Result<(), VMHooksError> {
        self.use_gas(
            self.gas_schedule()
                .managed_buffer_api_cost
                .m_buffer_get_bytes,
        )?;

        let bytes = self.m_types_lock().mb_get_owned(handle);
        self.finish_slice_u8(&bytes)
    }

    fn finish_i64(&mut self, value: i64) -> Result<(), VMHooksError> {
        if value == 0 {
            self.finish_slice_u8(&[])
        } else {
            self.finish_slice_u8(BigInt::from(value).to_signed_bytes_be().as_slice())
        }
    }

    fn finish_u64(&mut self, value: u64) -> Result<(), VMHooksError> {
        if value == 0 {
            self.finish_slice_u8(&[])
        } else {
            self.finish_slice_u8(BigUint::from(value).to_bytes_be().as_slice())
        }
    }
}
