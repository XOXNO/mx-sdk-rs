use std::{fs::File, io::Write};

use multiversx_sc::abi::{EndpointAbi, InputAbi, TypeDescription};

const PRELUDE: &str = "// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;";

pub(crate) fn write_header(file: &mut File) {
    writeln!(file, r#"{PRELUDE}"#).unwrap();
}

pub fn write_endpoint_docs(file: &mut File, docs: &Vec<String>) {
    for doc in docs {
        writeln!(file, "    /// {doc} ").unwrap();
    }
}

pub fn write_function_header_endpoint(file: &mut File, rust_method_name: &String) {
    write!(file, "    pub fn {rust_method_name}").unwrap();
}

pub fn write_parameters(file: &mut File, inputs: &[InputAbi]) {
    writeln!(file, "(").unwrap();
    writeln!(file, "        self,").unwrap();
    for (index, input) in inputs.iter().enumerate() {
        writeln!(file, "        {}: Arg{index},", &input.arg_name).unwrap();
    }
    write!(file, "    ) ").unwrap();
}

pub fn write_constructor_content(file: &mut File, inputs: Vec<InputAbi>) {
    writeln!(
        file,
        "        self.wrapped_tx
            .raw_deploy()"
    )
    .unwrap();
    for input in inputs.iter() {
        writeln!(file, "            .argument(&{})", input.arg_name).unwrap();
    }
    writeln!(file, "            .original_result()").unwrap();
}

pub fn write_upgrade_content(file: &mut File, inputs: Vec<InputAbi>) {
    writeln!(
        file,
        "        self.wrapped_tx
            .raw_upgrade()"
    )
    .unwrap();
    for input in inputs.iter() {
        writeln!(file, "            .argument(&{})", input.arg_name).unwrap();
    }
    writeln!(file, "            .original_result()").unwrap();
}

pub fn write_endpoint_content(file: &mut File, endpoint: &EndpointAbi) {
    writeln!(
        file,
        "        self.wrapped_tx
            .raw_call()
            .function_name(\"{}\")",
        endpoint.name
    )
    .unwrap();

    for input in endpoint.inputs.iter() {
        writeln!(file, "            .argument(&{})", input.arg_name).unwrap();
    }

    writeln!(file, "            .original_result()").unwrap();
}

pub fn write_end_of_function(file: &mut File) {
    writeln!(file, "    }}").unwrap();
}

pub fn start_write_type(
    file: &mut File,
    type_type: &str,
    type_description: &TypeDescription,
    name: &str,
) {
    writeln!(file).unwrap();
    write_macro_attributes(file, &type_description.macro_attributes);
    write!(file, r#"pub {type_type} {name}"#).unwrap();

    if name.contains("<Api>") {
        writeln!(
            file,
            r#"
where
    Api: ManagedTypeApi,"#
        )
        .unwrap();
    } else {
        write!(file, " ").unwrap();
    }

    writeln!(file, r#"{{"#).unwrap();
}

pub fn write_macro_attributes(file: &mut File, macro_attributes: &[String]) {
    if macro_attributes.is_empty() {
        writeln!(file, "#[derive(TopEncode, TopDecode)]").unwrap();
    } else {
        writeln!(file, "#[derive({})]", macro_attributes.join(", ")).unwrap();
    }
}

pub fn extract_struct_crate(struct_path: &str) -> String {
    let struct_crate_name = struct_path
        .replace('_', "-")
        .replace("multiversx_sc::api::uncallable::UncallableApi", "Api")
        .to_string();
    let crate_name = struct_crate_name
        .split("::")
        .next()
        .unwrap_or_else(|| &struct_crate_name);
    crate_name.to_string()
}
